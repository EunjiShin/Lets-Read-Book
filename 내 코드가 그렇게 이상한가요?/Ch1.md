# 1. 잘못된 구조의 문제 깨닫기
> <aside>
> ⚠️ 설계를 소홀히 했을 때 발생하는 폐해 <br>
> 1. 코드를 읽고 이해하기 어렵다 <br>
> 2. 버그가 계속 발생한다 <br>
> 3. 나쁜 구조로 인해 더 나쁜 구조가 만들어진다
</aside>

## 1.1 의미를 알 수 없는 이름

### 잘못된 네이밍 예시

- `기술 중심 명명` : 기술을 기반으로 이름 붙이는 것
    - ex. intValue, updateStateFlag, …
- `일련번호 명명` : 클래스와 메서드에 번호를 붙여 이름 짓는 것
    - ex. method001, method002, …

### 문제

- 코드에서 의도를 읽기 어려워져 읽고 이해하는데 시간이 오래 걸린다.
- 충분히 이해하지 못한 상태로 코드를 변경할 경우 버그가 발생할 수 있다.
- 일람표를 이용해 클래스와 메서드의 역할, 기능을 문서화하더라도, 유지 보수가 까다롭다.
    - 제때제때 업데이트 되지 않는다면 오히려 개발자를 더 헷갈리게 만들 수 있다.
- 의도를 제대로 이해하지 못한 개발자가 불필요하게 복잡한 로직을 짤 수 있다.

### 해결

- 의도와 목적을 드러내는 이름을 이용해 구조를 간단하고 명확하게 만들자.

---

## 1.2 이해하기 어렵게 만드는 조건 분기 중첩

<aside>
💡 **if 조건문이 중첩된 상태** : 말 그대로 if문 내부에 또 if문, 그 내부에 또 if문… 이 계속 중첩되는 상태

</aside>

### 거대한 중첩 예시

```java
if (조건) {
	// 코드들
	if (조건) {
		// 코드들 
		if (조건) {
			// 코드들
			if (조건) {
				// 코드들
			}
		}
		// 코드들
	}
	// 코드들
}
```

### 문제

- 어디서부터 어디까지가 한 블럭인지 확인하기 힘들어 코드 가독성이 나빠진다.
- 조건이 복잡해질 수록 코드를 이해하기 힘들어진다.
    - 디버깅과 기능 변경에도 더 많은 공수가 든다.
    - 로직을 제대로 이해하지 못한 채 기능을 변경하다 버그가 발생할 수 있다.

---

## 1.3 수많은 악마를 만들어 내는 데이터 클래스

<aside>
💡 **데이터 클래스** : 데이터를 갖고 있기만 하는 클래스

</aside>

### 데이터 클래스 예시

```java
public class ContractAmount {
	public int amountIncludingTax;
	public BigDecimal salesTaxRate;
}
```

- 각 인스턴스 변수가 public이므로, 클래스 밖에서도 데이터를 변경할 수 있다.
- ContractAmount는 데이터를 들고만 있고, 해당 데이터를 사용하는 계산 로직은 다른 클래스에 있는 상태.

## 문제

- **데이터와 로직이 분산되어 응집도가 낮은 구조**
    - 데이터와 계산 로직 클래스가 분리되어 있으므로, 데이터 클래스를 사용하는 개발자는 전체 클래스 설계를 외우지 않은 이상 로직 클래스의 존재 여부를 알 수 없다.
    - 따라서 동일 로직이 여러 곳에 구현되었을 가능성이 있고, 이 경우 사양이 바뀌면 수정할 곳이 많아진다.

<br>

- **응집도가 낮을 때 생기는 문제들**
    - `코드 중복`
        - 관련된 코드가 분산되어 있다면, 이미 구현된 기능인데도 없다고 오해하고 다시 구현할 수 있다.
    - `수정 누락`
        - 사양이 변경되면 중복된 코드를 모두 바꿔야 한다.
        - 이때 코드 중복이 많으면 수정이 누락될 수 있고, 이는 곧 버그로 이어진다.
    - `가독성 저하`
        - 코드 분산으로 인해 관련된 정보를 찾는 것이 힘들어져 가독성이 떨어진다.
        - 이는 소프트웨어가 커질 수록 심해진다.
    - `초기화되지 않은 상태 (쓰레기 객체)`

        > <aside>
        > 💡 **쓰레기 객체 안티패턴** <br>
        > : 초기화하지 않으면 쓸모 없는 클래스 또는 초기화하지 않은 상태가 발생할 수 있는 클래스
        > </aside>

        - ex. ContractAmount에서 salesTaxRate는 BigDecimal이므로 초기화하지 않으면 Null이다. 이를 모를 경우, ContractAmount를 사용하는 클라이언트 코드에서 NPE가 발생할 수 있다.
        - 즉, 데이터 클래스가 초기화 해야 하는 클래스라면 버그가 발생하기 쉬운 불완전한 클래스가 된다!
    - `잘못된 값 할당`

        > <aside>
        > 💡 **잘못된 값** <br>
        > : 요구사항에 맞지 않는 값이 할당된 상태 <br>
        > : ex. 주문 건수가 음수이거나, 게임에서 HP가 최댓값을 초과하거나. 
        > </aside>

        - ex. ContractAmount에서 amountIncludingTax는 소비세율을 의미하므로 항상 양수여야 하지만, 자료형이 int 이므로 음수가 할당될 수 있다.
        - 잘못된 값이 들어가지 않게 데이터 클래스를 사용하는 부분에 유효성 검사 로직을 추가할 수 있지만, 이 경우 마찬가지로 코드 중복이 발생하고, 수정 누락과 가독성 저하 문제로 이어질 수 있다.

<br>

- **따라서 데이터 클래스는 기능 응집도를 떨어뜨리고, 결과적으로 개발 생산성을 저하시킨다.**
